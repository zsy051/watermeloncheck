<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>音频检测系统</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
      width: 90%;
      height: 300px;
    }
    #controls {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h2>麦克风音频检测</h2>
  <div id="controls">
    <button id="toggleBtn">开始检测</button>
    <label for="updateInterval">更新时间 (ms): </label>
    <input id="updateInterval" type="number" value="100" step="10" min="10">
    <label for="threshold">分贝阈值 (dB): </label>
    <input id="threshold" type="number" value="-20" step="1" min="-50" max="0">
  </div>
  <canvas id="graphCanvas"></canvas>
  <p id="status">状态: 未开始检测</p>

  <script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const toggleBtn = document.getElementById('toggleBtn');
    const updateIntervalInput = document.getElementById('updateInterval');
    const thresholdInput = document.getElementById('threshold');
    const status = document.getElementById('status');

    canvas.width = window.innerWidth * 0.9;
    canvas.height = 300;

    let audioContext, analyser, microphoneStream, animationFrame;
    let isDetecting = false;
    let frequencyHistory = [];
    let dbHistory = [];
    const maxFrequency = 250; // Y轴频率上限
    const minDb = -50; // 分贝最低值
    const maxDb = 0; // 分贝最高值
    const historyDuration = 3; // 显示最近 3 秒的数据

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制坐标轴
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;

      // Y轴 (频率)
      ctx.beginPath();
      ctx.moveTo(50, 10);
      ctx.lineTo(50, canvas.height - 50);
      ctx.stroke();

      // Y轴 (分贝, 右侧)
      ctx.beginPath();
      ctx.moveTo(canvas.width - 50, 10);
      ctx.lineTo(canvas.width - 50, canvas.height - 50);
      ctx.stroke();

      // X轴
      ctx.beginPath();
      ctx.moveTo(50, canvas.height - 50);
      ctx.lineTo(canvas.width - 50, canvas.height - 50);
      ctx.stroke();

      // 绘制频率刻度
      const freqStep = maxFrequency / 5;
      const yStep = (canvas.height - 60) / 5;
      ctx.fillStyle = '#000';
      for (let i = 0; i <= 5; i++) {
        const y = canvas.height - 50 - i * yStep;
        ctx.fillText(`${(freqStep * i).toFixed(0)} Hz`, 10, y + 5);
        ctx.beginPath();
        ctx.moveTo(45, y);
        ctx.lineTo(55, y);
        ctx.stroke();
      }

      // 绘制分贝刻度
      const dbStep = (maxDb - minDb) / 5;
      for (let i = 0; i <= 5; i++) {
        const y = canvas.height - 50 - i * yStep;
        ctx.fillText(`${(minDb + dbStep * i).toFixed(0)} dB`, canvas.width - 45, y + 5);
        ctx.beginPath();
        ctx.moveTo(canvas.width - 55, y);
        ctx.lineTo(canvas.width - 45, y);
        ctx.stroke();
      }

      // 绘制频率曲线
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.beginPath();
      frequencyHistory.forEach((point, index) => {
        const x = 50 + (index / (historyDuration * 1000 / updateIntervalInput.value)) * (canvas.width - 100);
        const y = canvas.height - 50 - (point.frequency / maxFrequency) * (canvas.height - 60);
        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // 绘制分贝曲线
      ctx.strokeStyle = '#FF5733';
      ctx.beginPath();
      dbHistory.forEach((point, index) => {
        const x = 50 + (index / (historyDuration * 1000 / updateIntervalInput.value)) * (canvas.width - 100);
        const y = canvas.height - 50 - ((point.db - minDb) / (maxDb - minDb)) * (canvas.height - 60);
        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    async function startDetection() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioContext.createMediaStreamSource(microphoneStream);
      source.connect(analyser);

      analyser.fftSize = 2048;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      isDetecting = true;
      status.textContent = '状态: 正在检测';
      frequencyHistory = [];
      dbHistory = [];

      function updateData() {
        if (!isDetecting) return;

        analyser.getByteFrequencyData(dataArray);

        // 计算最大频率
        let maxIndex = 0;
        for (let i = 1; i < dataArray.length; i++) {
          if (dataArray[i] > dataArray[maxIndex]) maxIndex = i;
        }
        const nyquist = audioContext.sampleRate / 2;
        const frequency = (maxIndex / dataArray.length) * nyquist;

        // 计算分贝
        const db = 20 * Math.log10(Math.max(...dataArray) / 255);

        // 添加到历史记录
        if (frequency <= maxFrequency) frequencyHistory.push({ frequency });
        dbHistory.push({ db });

        // 保持最近 3 秒数据
        const maxPoints = Math.floor((historyDuration * 1000) / updateIntervalInput.value);
        if (frequencyHistory.length > maxPoints) frequencyHistory.shift();
        if (dbHistory.length > maxPoints) dbHistory.shift();

        drawGraph();
        setTimeout(updateData, updateIntervalInput.value);
      }
      updateData();
    }

    function stopDetection() {
      isDetecting = false;
      if (microphoneStream) {
        microphoneStream.getTracks().forEach((track) => track.stop());
      }
      status.textContent = '状态: 检测已停止';
    }

    toggleBtn.addEventListener('click', () => {
      if (isDetecting) {
        stopDetection();
        toggleBtn.textContent = '开始检测';
      } else {
        startDetection();
        toggleBtn.textContent = '停止检测';
      }
    });
  </script>
</body>
</html>